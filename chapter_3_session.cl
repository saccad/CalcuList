/* CalcuList Session of Tue Jan 12 16:56:01 CET 2021 */
fact(x) -> x<=1? 1: x*fact(x-1);
^ fact(5);
fib(x) -> x<=1? x: fib(x-1)+fib(x-2);
^ fib(10);
fibe1(x, f2, f1, k) -> x==k? f1: fibe1(x,f1,f1+f2,k+1);
fibe(x) -> x<=1? x: fibe1(x,0,1,1);
^ fibe(10);
^ fib(30);
^ fibe(30);
isLowerCase(c) -> 'a'<=c && c<='z';
toUpperCase(c) -> isLowerCase(c)? ('A'+c-'a') @char: c;
^ toUpperCase('b');
d = _gDate();
^ d;
^ d @type;
^ _pDate(d);
^ _pDate(d,"dd/MM/yyyy 'h:' HH.mm.ss");
dd = _gDate("1950/11/05 22:20:30:150","yyyy/MM/dd HH:mm:ss:SSS");
^ _pDate(dd);
^ _exp(1);
^ _log(3);
^ _pow(2,3);
log(b, x) -> _log(x)/_log(b);
^ log(2,8);
sqrt(x) -> _pow(x,1/2);
^ sqrt(16);
^ _len("bye");
^ _len([1, 2, 3]);
emp =  { "firstName": "Luisa", "lastName": "Cosentino", "age": 28, "projects": ["p1", "p3"] } ;
^ _len(emp);
^ _tuple(dd);
^ _tuple(emp);
isLeap(D) -> _tuple(D)[0]%4==0;
^ isLeap(_gDate());
^ _rand();
st = "01010101";
^ _ind(st,"10");
^ _ind(st,"100");
^ _ind(st,"10",4);
^ _ind(st,"10",6);
L1 = [1, 3, 5, 7, 9];
L2 = [0, 2, 4, 6, 8, 10, 12];
listReverse(L) -> L==[]? []: listReverse(L[>])+[L[.]];
^ listReverse(L1);
listMerge(O1, O2) -> O1==[]? O2[:]: O2==[]? O1[:]: O1[.]<O2[.]? [O1[.]|listMerge(O1[>],O2)]: [O2[.]|listMerge(O1,O2[>])];
^ listMerge(L1,L2);
^ L1;
^ L2;
reverse1(L, R) -> L==[]? R: reverse1(L[>],[L[.]|R]);
reverse(L) -> reverse1(L,[]);
range(x1, x2) -> x1>x2? []: [x1|range(x1+1,x2)];
L = range(1,1000);
^ listReverse(L);
^ reverse(L);
member(X, L) -> L==[]? false: L[.]==X? true: member(X,L[>]);
addEl(L, X) -> member(X,L)? L: [X|L];
listUnion(L1, L2) -> L2==[]? L1: listUnion(addEl(L1,L2[.]),L2[>]);
listAllProj(E) -> E==[]? []: E[.]["projects"]==null? listAllProj(E[>]): listUnion(listAllProj(E[>]),E[.]["projects"]);
dept = <<("dept_unical.dat"); { 
emps = dept["emps"];
^ listAllProj(emps);
is_odd(x) -> null;
is_even(x) -> x<0? is_even(-x): x==0? true: is_odd(x-1);
is_odd(x) -> x<0? is_odd(-x): x==0.0? false: is_even(x-1);
^ is_odd(-3);
^ is_even(-3);
filter(L, f/1) -> L==[]? []: f(L[.])? [L[.]|filter(L[>],f)]: filter(L[>],f);
d2or3(x) -> x%2==0 || x%3==0;
d2and3(x) -> x%2==0 && x%3==0;
^ filter(range(1,20),d2or3);
^ filter(range(1,20),d2and3);
map(L, f/1) -> L==[]? []: [f(L[.])|map(L[>],f)];
square(x) -> x*x;
cube(x) -> x*x*x;
^ map(range(1,10),square);
^ map(range(1,10),cube);
reduce(L, f/2, init) -> L==[]? init: f(L[.],reduce(L[>],f,init));
sum(x, y) -> x+y;
prod(x, y) -> x*y;
^ reduce(range(1,10),sum,0);
^ reduce(range(1,10),prod,1);
^ reduce(map(filter(range(1,10),d2and3),cube),sum,0);
merge(O1, O2, ord/2) -> O1==[]? O2[:]: O2==[]? O1[:]: ord(O1[.],O2[.])? [O1[.]|merge(O1[>],O2,ord)]: [O2[.]|merge(O1,O2[>],ord)];
lte(x, y) -> x<=y;
gte(x, y) -> x>=y;
L1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
L2 = [2, 4, 6, 8, 10, 16];
^ merge(L1,L2,lte);
^ merge(reverse(L1),reverse(L2),gte);
checkOrder(L, o/2) -> L==[] || L[>]==[]? true: o(L[.],L[1]) && checkOrder(L[>],o);
^ checkOrder(L1,lte);
^ checkOrder(reverse(L1),lte);
^ checkOrder(reverse(L1),gte);
jsFilter(LJ, filterCond/3, K, V) -> LJ==[]? []: filterCond(LJ[.],K,V)? [LJ[.]|jsFilter(LJ[>],filterCond,K,V)]: jsFilter(LJ[>],filterCond,K,V);
select1KV(J, K, V) -> J[K]!=null && J[K]==V;
^ jsFilter(emps,select1KV,"age",28);
select1KinV(J, K, V) -> J[K]!=null && member(V,J[K]);
^ jsFilter(emps,select1KinV,"projects","p1") %* ;
MATH: zeroDivide;
div*(x, y) -> <MATH*> {! zeroDivide=false !} y==0? 0 {! zeroDivide=true !} : x/y;
^ div(3,0);
^ MATH.zeroDivide;
^ div(2,3);
^ MATH.zeroDivide;
^ div(3,0) & MATH.zeroDivide? " error: zero divide!": "";
^ div(2,3) & MATH.zeroDivide? " error: zero divide!": "";
addProj1Emp*(E, p) -> E["projects"]==null?  {! E["projects"]=[p] !} true:  {! E["projects"]+=[p] !} true;
addProjEmps*(EL, p) -> EL==[]? true:  {! _=addProj1Emp(EL[.],p) !} addProjEmps(EL[>],p);
^ addProjEmps(emps,"p0");
^ emps %* ;
MATH: indeterm, div*/2;
MATH.div*(x, y) ->  {! zeroDivide=false & indeterm=false !} y!=0? x/y:  {! zeroDivide=true !} x!=0? 0: 0 {! indeterm=true !} ;
^ MATH.div(0,0);
^ MATH.zeroDivide;
^ MATH.indeterm;
: MATH;
^ div(0,0);
^ zeroDivide;
^ indeterm;
: _;
^ div(2,3);
^ MATH.indeterm;
digitVal(x) -> x-'0';
isDigit(x) -> '0'<=x && x<='9';
INT: val, base10exp, rec*/1, rec1*/2, natRec*/3;
: INT;
rec*(S) -> rec1(S,_len(S));
rec1*(S, l) -> l==0? false: S[0]=='-'? natRec(S,l,1) {! val=-val !} : S[0]=='+'? natRec(S,l,1): natRec(S,l,0);
natRec*(S, l, i) -> i>=l || !isDigit(S[i])? false: i==l-1? true {! val=digitVal(S[i]) & base10exp=1 !} : natRec(S,l,i+1) {! base10exp*=10 !}  {! val+=base10exp*digitVal(S[i]) !} ;
^ rec("+");
^ rec("+2384");
^ val;
^ rec("-2384");
^ val;
INT2: err, natRec*/4, rec*/1, rec1*/2, printErr/1;
: INT2;
natRec*(S, v, l, i) -> i>=l || !isDigit(S[i])? 0 {! err=true !} : i==l-1? v*10+digitVal(S[i]): natRec(S,v*10+digitVal(S[i]),l,i+1);
rec1*(S, l) ->  {! err=false !} l==0? 0 {! err=true !} : S[0]=='-'? -natRec(S,0,l,1): S[0]=='+'? natRec(S,0,l,1): natRec(S,0,l,0);
rec*(S) -> rec1(S,_len(S));
printErr(e) -> e? " wrong integer string!": "";
^ rec("-") & printErr(err);
^ rec("-2384") & printErr(err);
^ rec("2384") & printErr(err);
INT_EXC: rec/1, natRec/4, rec1/2;
: INT_EXC;
natRec(S, v, l, i) -> i>=l || !isDigit(S[i])? exc("Wrong Integer String"): i==l-1? v*10+digitVal(S[i]): natRec(S,v*10+digitVal(S[i]),l,i+1);
rec1(S, l) -> l==0? exc("Empty String"): S[0]=='-'? -natRec(S,0,l,1): S[0]=='+'? natRec(S,0,l,1): natRec(S,0,l,0);
rec(S) -> rec1(S,_len(S));
^ rec("-");
^ rec("-2384");
INT_LIST: natRec/4, rec/1, rec1/2, chs/1;
: INT_LIST;
chs(L) -> [-L[0], L[1]];
natRec(S, v, l, i) -> i>=l || !isDigit(S[i])? [0, false]: i==l-1? [v*10+digitVal(S[i]), true]: natRec(S,v*10+digitVal(S[i]),l,i+1);
rec1(S, l) -> l==0? [0, false]: S[0]=='-'? chs(natRec(S,0,l,1)): S[0]=='+'? natRec(S,0,l,1): natRec(S,0,l,0);
rec(S) -> rec1(S,_len(S));
^ rec("-");
^ rec("-2384");
INT_LIST2: natRec/4, rec/1, chs/1;
: INT_LIST2;
chs(L) -> [-L[0], L[1]];
natRec(S, v, l, i) -> i>=l || !isDigit(S[i])? [0, false]: i==l-1? [v*10+digitVal(S[i]), true]: natRec(S,v*10+digitVal(S[i]),l,i+1);
rec(S) -> <l> {! l=_len(S) !} l==0? [0, false]: S[0]=='-'? chs(natRec(S,0,l,1)): S[0]=='+'? natRec(S,0,l,1): natRec(S,0,l,0);
^ rec("-");
^ rec("-2384");
POLY2_ROOT: noRoots, indRoots, complRoots, solve_ext*/3, printErr*/0;
: POLY2_ROOT;
printErr*() -> noRoots? " * no solutions": indRoots? " * indeterminate solutions": complRoots? " * complex solutions": "";
solve_ext*(a, b, c) -> <disc,rdisc,b2a> {! noRoots=false & indRoots=false & complRoots=false !} a==0? b==0? c==0?  {! indRoots=true !} []:  {! noRoots=true !} []: [-c/b]:  {! disc=b*b-4*a*c !} disc<0?  {! complRoots=true !} []: disc==0?  {! b2a=-b/(2*a) !} [b2a, b2a]:  {! rdisc=sqrt(disc) !} [(-b-rdisc)/(2*a), (-b+rdisc)/(2*a)];
^ solve_ext(0,0,0) & printErr();
^ solve_ext(0,0,1) & printErr();
^ solve_ext(2,1,1) & printErr();
^ solve_ext(2,4,-4) & printErr();
: _;
swap*(L, i, j) -> <tmp> {! tmp=L[i] !}  {! L[i]=L[j] !}  {! L[j]=tmp !} true;
K = [1, 2, 3, 4];
^ swap(K,1,3);
^ K;
^ swap(K,2,5);
BUBBLE_SORT: pass*/3, iter*/2, sort*/1;
: BUBBLE_SORT;
sort*(L) -> L==[]? L: iter(L,_len(L)-2);
pass*(L, i, last) -> i>last? null: L[i]>L[i+1]?  {! _=swap(L,i,i+1) !} pass(L,i+1,last): pass(L,i+1,last);
iter*(L, last) -> last<0? L:  {! _=pass(L,0,last) !} iter(L,last-1);
L = [3, 1, 7, 4, 0, 5, 13, 11, -1];
^ sort(L);
pass*(L, i, last) -> i>last? null: L[0]>L[1]?  {! _=swap(L,0,1) !} pass(L[>],i+1,last): pass(L[>],i+1,last);
L = [3, 1, 7, 4, 0, 5, 13, 11, -1];
^ sort(L);
MATH_LIST: zeroDivide, numZD, div*/2, div1*/2;
: MATH_LIST;
div*(x, L) ->  {! zeroDivide=false & numZD=0 !} div1(x,L);
div1*(x, L) -> <MATH*,d>L==[]? []:  {! d=MATH.div(x,L[.]) !} MATH.zeroDivide?  {! MATH_LIST.zeroDivide=true & numZD+=1 !} div1(x,L[>]): [d|div1(x,L[>])];
^ div(2,[2, 0, -4, 0, 1, 0, 5]);
^ zeroDivide;
^ numZD;
^ MATH.zeroDivide;
^ checkOrder(L1,\ x,y -> x<y);
^ reduce(map(filter(range(1,20),\ x -> x%5==0),\ x -> 2*x),\ x,y -> x+y,0);
mapRed5(L) -> reduce(map(filter(L,\ x -> x%5==0),\ x -> 2*x),\ x,y -> x+y,0);
^ mapRed5(range(1,20));
f(g/2, x) -> x+2+g(x,2*x);
a(x, y) -> x+y;
^ f(\ x,y -> x+f(a,y),3);
twice(f/1)/1 -> \ x -> f(f(x));
add3(x) -> x+3;
^ twice(add3)(7);
^ twice(\ x -> x*x)(7);
fMapRed(f/1, m/1, r/2, in)/1 -> \ L -> reduce(map(filter(L,f),m),r,in);
^ fMapRed(d2and3,cube,sum,0)(range(1,10));
